# JS内存管理与垃圾回收

## 内存管理

### JavaScript内存空间模型

* 代码空间：存放可执行代码
* 栈空间：即JavaScript的调用栈，存放执行上下文（以及其中的原始数据类型）
* 堆空间：存放引用数据类型，栈空间中保存引用数据类型的引用（内存地址）

为什么要分栈空间和堆空间？

栈空间需要维护执行上下文，而引用数据类型占用内存太大，存放在栈空间中会影响上下文切换效率进而影响程序执行效率。

### 内存生命周期

不管什么程序语言，内存的生命周期基本一致：

1. 分配内存
2. 使用内存（读/写）
3. 回收内存

所有的程序语言在「使用内存（读/写）」上都是明确的，底层语言的「分配内存」和「回收内存」也是明确的，但在包括JavaScript在内的大部分高级程序语言中是隐含的。

## 垃圾回收

### 引用计数算法（Reference Counting）

#### 核心思想

引用计数算法的核心思想是跟踪每个对象被引用的次数。

每个对象都有一个与之关联的计数器，当有一个变量或属性引用该对象时，计数器就递增，当引用被删除时，计数器就递减。如果一个对象的引用计数为0，表示没有任何引用指向该对象，此时认为该对象不再被需要，垃圾回收器就可以释放该对象占用的内存空间。

```
```

/图例占位

#### 优点

* 算法简单，容易理解
* 内存回收具有即时性，计数为0时可以马上回收

#### 缺点

* 维护引用计数需要消耗资源，有时可能会对系统性能产生影响
* 无法处理循环引用

**循环引用**

```
function fn(){
  const obj1 = {a:1};
  const obj2 = {b:1};
  obj1.a = obj2;
  obj2.b = obj1;
}
```

fn执行上下文即将出栈时的状态：

/图例占位

fn执行上下文出栈后的状态：

/图例占位

可见两块内存的引用计数仍然为1 ，无法进行内存回收，造成内存泄漏。

### 标记清除算法（Mark-and-Sweep）

#### 核心思想

标记清除算法的核心思想是找到所有从root出发可达的对象。（在javaScript中root为全局对象）

标记阶段：从root出发，递归遍历所有可达的对象。每访问一个对象，就将其标记为“active”。

清除阶段：遍历全部对象，清理那些在标记阶段没有被标记的对象，并回收它们所占用的内存空间。

```
function fn(){
  
}
```

/图例占位

#### 优点

* 可以处理循环引用
* 无需维护计数

#### 缺点

* 清理后可能引起内存碎片，但现在垃圾回收器都会有相应优化
* 非实时性，清理过程中可能造成程序暂停，称为"全停顿"（Stop-The-World）

**全停顿（Stop-The-World）**

垃圾回收器会在回收内存前暂停程序的执行，等到垃圾回收过程结束后再恢复执行。这种行为被称为全停顿。

全停顿的原因：

* 保证一致性：在执行标记和清除过程时，垃圾回收器需要确定哪些对象是“可达的”，并且保证在这个过程中对象的状态不会改变。如果程序在执行这一过程的同时继续运行，可能就会改变对象的引用关系，导致垃圾回收器的判断不准确。
* 回收内存：在清除阶段，垃圾回收器需要回收那些已经确定为垃圾的对象所占用的内存空间。如果程序在这个过程中仍然在执行，并且有可能正在使用或分配新的对象，那么就可能会出现内存访问的冲突，导致程序崩溃或出现未定义行为。

为了减轻停顿时间对程序性能的影响，现代垃圾回收器采用了许多不同的策略，如V8引擎的增量标记（Incremental Marking）算法。

从 2012 年起，所有现代浏览器都使用了标记 - 清除垃圾回收算法。所有对 JavaScript 垃圾回收算法的改进都是基于标记 - 清除算法的改进。

### V8引擎的垃圾回收策略 - 分代垃圾回收

分代垃圾回收将堆内存分为了两个空间：新生代和老生代。

新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。

新生代的空间小于老生代，但新生代中的垃圾回收更为频繁。

V8引擎使用两个垃圾回收器分别作用于新生代（副垃圾回收器）和老生代（主垃圾回收器）。主垃圾回收器和副垃圾回收器都是基于标记-清除算法的。

#### 副垃圾回收器

副垃圾回收器采用scavenge算法，该算法将新生代又对半分为两个区域：对象区域和空闲区域。

新加入的对象会加入到对象区域，对象区域将满时会进行一次标记-清除垃圾回收，将仍存活的对象复制到空闲区域中连续的内存空间，这个复制的过程相当于完成了内存整理，即不会产生内存碎片。然后将对象区域清空，这个时候，对象区域也就变成了新的空闲区域。

由于新生代的空间有限，所以V8引擎采用了对象晋升策略，连续两次垃圾回收仍存活的对象将会被移动到老生代。

#### 主垃圾回收器

除了新生代晋升的对象，一些大的对象也会直接存到老生代中，因此老生代中的对象有两个特点：存活时间久，占用空间大。

因此主垃圾回收器不适合使用scavenge算法，一来存活时间久导致复制操作频繁，二来占用空间大导致复制操作消耗大。

主垃圾回收器在标记-清除算法的基础上进行优化，在标记和清除中加上了整理，即标记-整理-清除过程：标记阶段后，将存活的对象向内存的一端移动，然后直接清除这一端边界以外的空间，这样的好处是不会产生内存碎片。

#### 全停顿的优化

在新生代中，由于空间小且对象生存时间短，全停顿的影响并不大。

在老生代中，V8引擎采用了增量标记算法进行优化。

**增量回收（增量标记算法）**

增量回收的核心思想是将这个连续的垃圾回收过程分解为多个小的片段。

增量回收是一种时间分片的策略，目的是在程序的正常执行和垃圾回收之间进行合理的切换。垃圾回收器不会一次执行所有的工作，而是执行一小部分垃圾回收任务，然后允许程序执行一段时间，再执行下一部分垃圾回收，如此往复直到整个回收过程完成。

普通垃圾回收：

![](https://alidocs.dingtalk.com/core/api/resources/img/5eecdaf48460cde521fd75ccbf3e03f1de82323aaacfe4ef58e70b814913bc360a414d3de9277d871abf3af1cbd752498a99ecfba85816cca04d8015c967cde75006a51a37ee308f7bb9070c461b4276c98bc4bef9ddc93bfc653b69905bac42?tmpCode=bedb558f-24d9-4142-8210-0bb19630c56d)

增量回收：

![](https://alidocs.dingtalk.com/core/api/resources/img/5eecdaf48460cde521fd75ccbf3e03f1de82323aaacfe4ef58e70b814913bc360a414d3de9277d871abf3af1cbd75249366f1b75bd3d165363d85b7138b7d7be14c3b88614df3763726263974cc625c38d4ba462109ee6c1fc653b69905bac42?tmpCode=bedb558f-24d9-4142-8210-0bb19630c56d)
